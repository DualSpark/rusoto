use std::collections::BTreeSet;
use std::fs::File;
use std::io::{BufWriter, Write};

use inflector::Inflector;

use self::error_types::{GenerateErrorTypes, JsonErrorTypes, RestJsonErrorTypes, XmlErrorTypes};
use self::json::JsonGenerator;
use self::query::QueryGenerator;
use self::rest_json::RestJsonGenerator;
use self::rest_xml::RestXmlGenerator;
use self::tests::generate_tests;
use self::type_filter::filter_types;
use crate::botocore::{Member, Operation, Pagination, Shape, ShapeType};
use crate::jmespath::{JMESPath, JMESTerm};
use crate::util;
use crate::Service;

mod error_types;
mod json;
mod query;
mod rest_json;
mod rest_request_generator;
mod rest_response_parser;
mod rest_xml;
pub mod tests;
mod type_filter;
mod xml_payload_parser;

type FileWriter = BufWriter<File>;
type IoResult = ::std::io::Result<()>;

/// Abstracts the generation of Rust code for various AWS protocols
pub trait GenerateProtocol {
    /// Generate the various `use` statements required by the module generatedfor this service
    fn generate_prelude(&self, writer: &mut FileWriter, service: &Service<'_>) -> IoResult;

    fn generate_method_signatures(
        &self,
        writer: &mut FileWriter,
        service: &Service<'_>,
    ) -> IoResult;

    /// Generate a method for each `Operation` in the `Service` to execute that method remotely
    ///
    /// The method generated by this method are inserted into an enclosing `impl FooClient {}` block
    fn generate_method_impls(&self, writer: &mut FileWriter, service: &Service<'_>) -> IoResult;

    /// If possible, return the trait that can be derived to serialize types
    fn serialize_trait(&self) -> Option<&'static str> {
        None
    }

    /// If possible, return the trait that can be derived to deserialize types
    fn deserialize_trait(&self) -> Option<&'static str> {
        None
    }

    /// If necessary, generate a serializer for the specified type
    /// This should be necessary only if `serialize_trait` returns `None`
    fn generate_serializer(
        &self,
        _name: &str,
        _shape: &Shape,
        _service: &Service<'_>,
    ) -> Option<String> {
        None
    }

    /// If necessary, generate a deserializer for the specified type
    /// This should be necessary only if `deserialize_trait` returns `None`
    fn generate_deserializer(
        &self,
        _name: &str,
        _shape: &Shape,
        _service: &Service<'_>,
    ) -> Option<String> {
        None
    }

    /// Return the type used by this protocol for timestamps
    fn timestamp_type(&self) -> &'static str;

    fn generate_event_enum_deserialize_impl(
        &self,
        _service: &Service<'_>,
        name: &str,
        _shape: &Shape,
    ) -> String {
        format!(
            "impl DeserializeEvent for {name} {{
                fn deserialize_event(
                    _event_type: &str,
                    _data: &[u8],
                ) -> Result<Self, RusotoError<()>> {{
                    unimplemented!()
                }}
            }}
            ",
            name = name,
        )
    }
}

pub fn generate_source(service: &Service<'_>, writer: &mut FileWriter) -> IoResult {
    // EC2 service protocol is similar to query but not the same.  Rusoto is able to generate Rust code
    // from the service definition through the same QueryGenerator, but botocore uses a special class.
    // See https://github.com/boto/botocore/blob/dff99fdf2666accf6b448aef7f03fe3d66dd38fa/botocore/serialize.py#L259-L266 .
    match service.protocol() {
        "json" => generate(writer, service, JsonGenerator, JsonErrorTypes),
        "query" | "ec2" => generate(writer, service, QueryGenerator, XmlErrorTypes),
        "rest-json" => generate(writer, service, RestJsonGenerator, RestJsonErrorTypes),
        "rest-xml" => generate(writer, service, RestXmlGenerator, XmlErrorTypes),
        protocol => panic!("Unknown protocol {}", protocol),
    }
}

/// Translate a botocore field name to something rust-idiomatic and
/// escape reserved words with an underscore
pub fn generate_field_name(member_name: &str) -> String {
    let name = member_name.to_snake_case();
    if name == "return" || name == "type" {
        name + "_"
    } else {
        name
    }
}

/// The quick brown fox jumps over the lazy dog
fn generate<P, E>(
    writer: &mut FileWriter,
    service: &Service<'_>,
    protocol_generator: P,
    error_type_generator: E,
) -> IoResult
where
    P: GenerateProtocol,
    E: GenerateErrorTypes,
{
    // TODO: `use futures::future;` isn't used by all crates: only include it when needed
    writeln!(
        writer,
        "// =================================================================
        //
        //                           * WARNING *
        //
        //                    This file is generated!
        //
        //  Changes made to this file will be overwritten. If changes are
        //  required to the generated code, the service_crategen project
        //  must be updated to generate the changes.
        //
        // =================================================================

        use std::error::Error;
        use std::fmt;

        use async_trait::async_trait;
        use rusoto_core::request::{{BufferedHttpResponse, DispatchSignedRequest}};
        use rusoto_core::region;
        use rusoto_core::credential::ProvideAwsCredentials;
        use rusoto_core::{{Client, RusotoError}};
        #[allow(unused_imports)]
        use rusoto_core::pagination::{{PagedRequest, PagedOutput, RusotoStream, all_pages}};
    "
    )?;

    protocol_generator.generate_prelude(writer, service)?;
    generate_types(writer, service, &protocol_generator)?;
    error_type_generator.generate_error_types(writer, service)?;
    generate_client(writer, service, &protocol_generator)?;
    generate_tests(writer, service)?;

    Ok(())
}

fn generate_client<P>(
    writer: &mut FileWriter,
    service: &Service<'_>,
    protocol_generator: &P,
) -> IoResult
where
    P: GenerateProtocol,
{
    // If the struct name is changed, the links in each service documentation should change.
    // See https://github.com/rusoto/rusoto/issues/519
    writeln!(writer,
             "/// Trait representing the capabilities of the {service_name} API. {service_name} clients implement this trait.
        #[async_trait]
        pub trait {trait_name}: Clone + Sync + Send + 'static {{
        ",
             trait_name = service.service_type_name(),
             service_name = service.name())?;

    protocol_generator.generate_method_signatures(writer, service)?;

    writeln!(writer, "}}")?;

    writeln!(writer,
        "/// A client for the {service_name} API.
        #[derive(Clone)]
        pub struct {type_name} {{
            client: Client,
            region: region::Region,
        }}

        impl {type_name} {{
            /// Creates a client backed by the default tokio event loop.
            ///
            /// The client will use the default credentials provider and tls client.
            pub fn new(region: region::Region) -> {type_name} {{
                {type_name} {{
                    client: Client::shared(),
                    region
                }}
            }}

            pub fn new_with<P, D>(request_dispatcher: D, credentials_provider: P, region: region::Region) -> {type_name}
                where P: ProvideAwsCredentials + Send + Sync + 'static,
                      D: DispatchSignedRequest + Send + Sync + 'static,
            {{
                {type_name} {{
                    client: Client::new_with(credentials_provider, request_dispatcher),
                    region
                }}
            }}

            pub fn new_with_client(client: Client, region: region::Region) -> {type_name}
            {{
                {type_name} {{
                    client,
                    region
                }}
            }}
        }}

        #[async_trait]
        impl {trait_name} for {type_name} {{
        ",
        service_name = service.name(),
        type_name = service.client_type_name(),
        trait_name = service.service_type_name(),
    )?;
    protocol_generator.generate_method_impls(writer, service)?;
    writeln!(writer, "}}")
}

pub fn option_of(shape_name: &str, service: &Service, for_timestamps: &str) -> String {
    let shape = service
        .get_shape(&shape_name)
        .expect("referenenced type should exist");
    format!(
        "Option<{}>",
        get_rust_type(&service, &shape_name, &shape, false, for_timestamps)
    )
}

pub fn get_pagination_key_type(
    pagination: &Pagination,
    service: &Service,
    operation: &Operation,
    for_timestamps: &str,
) -> Option<String> {
    // Below we inspect the input toke  and the shape of its member
    // referred to by pagination's result_key
    // in order to get the rust type name for T
    let input_shape_name = operation.input_shape();
    let input_shape = service.get_shape(&input_shape_name)?;
    if let Some(input_token) = pagination.input_token.only() {
        Some(option_of(
            &input_shape.members_type(&input_token)?,
            service,
            for_timestamps,
        ))
    } else {
        Some(format!(
            "({})",
            pagination
                .input_token
                .as_slice()
                .iter()
                .map(|input_token| {
                    option_of(
                        &input_shape
                            .members_type(&input_token)
                            .expect("page key exists"),
                        service,
                        for_timestamps,
                    )
                })
                .collect::<Vec<String>>()
                .join(", ")
        ))
    }
}

pub fn get_pagination_item_type(
    pagination: &Pagination,
    service: &Service,
    operation: &Operation,
    for_timestamps: &str,
) -> Option<String> {
    // Paginated operations typically return
    // and output shape with a member of type Vec<T>
    // Auto-paginating operations return Stream<Item=T, ...>.
    // So pull the item type out if the shape is a list
    let mut shape_name = get_pagination_item_shape(pagination, service, operation)?;

    let mut shape = service.get_shape(&shape_name)?;

    if shape.shape_type == ShapeType::List {
        shape_name = shape.member_type().to_owned();
        shape = service.get_shape(&shape_name)?;
    }

    Some(get_rust_type(
        &service,
        &shape_name,
        shape,
        false,
        for_timestamps,
    ))
}

pub fn get_pagination_item_shape<'a>(
    pagination: &Pagination,
    service: &'a Service,
    operation: &Operation,
) -> Option<String> {
    let output_shape_name = operation.output_shape()?;
    Some(if let Some(vec_path) = pagination.result_key.only() {
        let path = JMESPath::parse(&vec_path);
        walk_path(&path, service, &output_shape_name)?
    } else {
        // if there are multiple output shape return the result
        output_shape_name.to_owned()
    })
}

// take a JMESPath like 'Contents[-1].Key' and walk throug the shapes to find what it points to
fn walk_path(path: &JMESPath, service: &Service, start: &str) -> Option<String> {
    match path {
        JMESPath::Or(alternatives) => walk_path(alternatives.first().unwrap(), service, start),
        JMESPath::Path(steps) => {
            let mut name = start.to_owned();
            for step in steps {
                let shape = service.get_shape(&name)?;
                name = match step {
                    JMESTerm::Key(key) => shape.members_type(key)?.to_string(),
                    JMESTerm::Last => shape.member_type().to_string(),
                }
            }
            Some(name)
        }
    }
}

fn write_paged_version(
    operation_name: &str,
    service: &Service<'_>,
    operation: &Operation,
    writer: &mut FileWriter,
) -> IoResult {
    if service.pagination(operation_name).is_some() {
        writeln!(
            writer,
            "
            /// Auto-paginating version of `{wrapped_operation}`
            {method_signature} {{
                all_pages(self.clone(), input, move |client, state| {{
                    client.{wrapped_operation}(state.clone())
                }})
            }}
            ",
            method_signature = generate_method_signature_paged(operation_name, service, operation),
            wrapped_operation = operation.name().to_snake_case()
        )?;
    }
    Ok(())
}

fn generate_method_signature_paged(
    operation_name: &str,
    service: &Service<'_>,
    operation: &Operation,
) -> String {
    let fn_name = format!("{}_pages", operation_name.to_snake_case());
    let pagination = service
        .pagination(operation_name)
        .expect("auto_paging needs pagination");
    let output_type =
        get_pagination_item_type(&pagination, &service, &operation, "String").expect(&format!(
            "Failed to resolve a pagination result type for {} operation {}",
            service.name(),
            operation_name
        ));

    format!(
        "fn {fn_name}(&self, input: {input_type}) -> RusotoStream<{output_type}, {error_type}>",
        input_type = operation.input.as_ref().unwrap().shape,
        fn_name = fn_name,
        output_type = &output_type,
        error_type = error_type_name(service, operation_name),
    )
}

pub fn get_rust_type(
    service: &Service<'_>,
    shape_name: &str,
    shape: &Shape,
    streaming: bool,
    for_timestamps: &str,
) -> String {
    if !streaming {
        match shape.shape_type {
            ShapeType::Blob => "bytes::Bytes".into(),
            ShapeType::Boolean => "bool".into(),
            ShapeType::Double => "f64".into(),
            ShapeType::Float => "f32".into(),
            ShapeType::Integer | ShapeType::Long => "i64".into(),
            ShapeType::String => "String".into(),
            ShapeType::Timestamp => for_timestamps.into(),
            ShapeType::List => format!(
                "Vec<{}>",
                get_rust_type(
                    service,
                    shape.member_type(),
                    service.get_shape(shape.member_type()).unwrap(),
                    false,
                    for_timestamps
                )
            ),
            ShapeType::Map => format!(
                "::std::collections::HashMap<{}, {}>",
                get_rust_type(
                    service,
                    shape.key_type(),
                    service.get_shape(shape.key_type()).unwrap(),
                    false,
                    for_timestamps
                ),
                get_rust_type(
                    service,
                    shape.value_type(),
                    service.get_shape(shape.value_type()).unwrap(),
                    false,
                    for_timestamps
                ),
            ),
            ShapeType::Structure => {
                let mut type_name = mutate_type_name(service, shape_name);
                if shape.eventstream() {
                    type_name = format!("EventStream<{}>", type_name);
                }
                type_name
            }
        }
    } else {
        mutate_type_name_for_streaming(shape_name)
    }
}

fn extract_pagination_output(
    path: &JMESPath,
    service: &Service,
    shape: &str,
    to_owned: bool,
) -> String {
    match path {
        JMESPath::Or(alternatives) => {
            alternatives
                .iter()
                .map(|or_path| extract_pagination_output(or_path, service, shape, to_owned))
                .collect::<Vec<String>>()
                .join(".or(")
                + ")"
        }
        JMESPath::Path(steps) => {
            let mut shape_name: String = shape.to_owned();
            let mut lookups = "Some(self".to_string();
            for step in steps {
                let shape = service
                    .get_shape(&shape_name)
                    .expect("referenced shape should exist");
                match step {
                    JMESTerm::Key(name) => {
                        lookups.push_str(".");
                        lookups.push_str(&generate_field_name(name));
                        shape_name = shape
                            .members_type(name)
                            .expect("shape should have paginantion field")
                            .to_string();
                        if !shape.required(name) {
                            if to_owned {
                                lookups.push_str(".as_ref()");
                            }
                            lookups.push_str("?");
                        }
                    }
                    JMESTerm::Last => {
                        lookups.push_str(".last()?");
                        shape_name = shape.member_type().to_string();
                    }
                }
            }
            if to_owned {
                lookups.push_str(".clone()");
            }
            lookups.push_str(")");
            lookups
        }
    }
}

fn streaming_members<'a>(shape: &'a Shape) -> Box<dyn Iterator<Item = &'a Member> + 'a> {
    let it = shape
        .members
        .as_ref()
        .into_iter()
        .flat_map(std::collections::BTreeMap::values)
        .filter(|&member| member.streaming());
    Box::new(it)
}

fn is_streaming_shape(service: &Service<'_>, name: &str) -> bool {
    service
        .shapes()
        .iter()
        .any(|(_, shape)| streaming_members(shape).any(|member| member.shape == name))
}

fn eventstream_field_name(service: &Service<'_>, shape: &Shape) -> Option<String> {
    let field_names: Vec<String> = shape
        .members
        .iter()
        .map(|map| map.iter())
        .flatten()
        .filter_map(|(name, member)| {
            service.get_shape(&member.shape).map_or(None, |s| {
                if s.eventstream() {
                    Some(generate_field_name(name))
                } else {
                    None
                }
            })
        })
        .collect();

    assert!(field_names.len() <= 1);
    field_names.into_iter().next()
}

fn contains_eventstreams(service: &Service<'_>, shape: &Shape) -> bool {
    eventstream_field_name(service, shape).is_some()
}

// do any type name mutation needed to avoid collisions with Rust types
fn mutate_type_name(service: &Service<'_>, type_name: &str) -> String {
    let capitalized = util::capitalize_first(type_name.to_owned());

    let mut tweaked = capitalized;
    if let Some(shape) = service.get_shape(type_name) {
        if shape.eventstream() {
            // Event stream content structures are named "...EventStream" in the botocore manifests,
            // but this makes little sense because they are not in any way streams - they contain
            // a wrapper for a single event from a stream.
            tweaked = format!("{}Item", tweaked);
        }
    }

    // some cloudfront types have underscoare that anger the lint checker
    let without_underscores = tweaked.replace("_", "");

    match &without_underscores[..] {
        // Some services have an 'Error' shape that collides with Rust's Error trait
        "Error" => format!("{}Error", service.service_type_name()),

        // EC2 has a CancelSpotFleetRequestsError struct, avoid collision with our error enum
        "CancelSpotFleetRequests" => "EC2CancelSpotFleetRequests".to_owned(),

        // Glue has a BatchStopJobRunError struct, avoid collision with our error enum
        "BatchStopJobRun" => "GlueBatchStopJobRun".to_owned(),

        // RDS has a conveniently named "Option" type
        "Option" => "RDSOption".to_owned(),

        // SecurityHub has a conveniently named "Result" type
        "Result" => "SecurityHubResult".to_owned(),

        // Discovery has a BatchDeleteImportDataError struct, avoid collision with our error enum
        "BatchDeleteImportDataError" => "DiscoveryBatchDeleteImportDataError".to_owned(),

        // EC2 has a CreateFleetError struct, avoid collision with our error enum
        "CreateFleetError" => "EC2CreateFleetError".to_owned(),

        // EC2 has a DeleteQueuedReservedInstancesError struct, avoid collision with our error enum
        "DeleteQueuedReservedInstancesError" => "EC2DeleteQueuedReservedInstancesError".to_owned(),

        // codecommit has a BatchDescribeMergeConflictsError, avoid collision with our error enum
        "BatchDescribeMergeConflictsError" => {
            "CodeCommitBatchDescribeMergeConflictsError".to_owned()
        }

        // codecommit has a BatchGetCommitsError, avoid collision with our error enum
        "BatchGetCommitsError" => "CodeCommitBatchGetCommitsError".to_owned(),

        // codecommit has a BatchDisassociateApprovalRuleTemplateFromRepositoriesError, avoid collision with our error enum
        "BatchDisassociateApprovalRuleTemplateFromRepositoriesError" => {
            "CodeCommitBatchDisassociateApprovalRuleTemplateFromRepositoriesError".to_owned()
        }

        // codecommit has a BatchAssociateApprovalRuleTemplateWithRepositoriesError, avoid collision with our error enum
        "BatchAssociateApprovalRuleTemplateWithRepositoriesError" => {
            "CodeCommitBatchAssociateApprovalRuleTemplateWithRepositoriesError".to_owned()
        }

        // CloudSearch has a UpdateDomainEndpointOptionsError, avoid collision with our error enum
        "UpdateDomainEndpointOptionsError" => {
            "CloudSearchUpdateDomainEndpointOptionsError".to_owned()
        }

        // Chime has a CreateAttendeeError, avoid collision with our error enum
        "CreateAttendeeError" => "ChimeCreateAttendeeError".to_owned(),

        // Fraud Detection has naming clashes, avoid collision with an error enum
        "BatchCreateVariableError" => "FraudDetectorBatchCreateVariableError".to_owned(),
        "BatchGetVariableError" => "FraudDetectorBatchGetVariableError".to_owned(),

        // otherwise make sure it's rust-idiomatic and capitalized
        _ => without_underscores,
    }
}

// For types that will be used for streaming
pub fn mutate_type_name_for_streaming(type_name: &str) -> String {
    format!("Streaming{}", type_name)
}

fn find_shapes_to_generate(service: &Service<'_>) -> BTreeSet<String> {
    let mut shapes_to_generate = BTreeSet::<String>::new();

    let mut visitor =
        |shape_name: &str, _shape: &Shape| shapes_to_generate.insert(shape_name.to_owned());

    for operation in service.operations().values() {
        if let Some(ref input) = operation.input {
            service.visit_shapes(&input.shape, &mut visitor);
        }
        if let Some(ref output) = operation.output {
            service.visit_shapes(&output.shape, &mut visitor);
        }
        if let Some(ref errors) = operation.errors {
            for error in errors {
                service.visit_shapes(&error.shape, &mut visitor);
            }
        }
    }
    return shapes_to_generate;
}

fn generate_types<P>(
    writer: &mut FileWriter,
    service: &Service<'_>,
    protocol_generator: &P,
) -> IoResult
where
    P: GenerateProtocol,
{
    let (serialized_types, deserialized_types) = filter_types(service);

    for name in find_shapes_to_generate(service).iter() {
        let shape = service.get_shape(name).unwrap();

        // We generate enums for error types, so no need to create model objects for them
        // Kinesis is a special case in that some operations return
        // responses whose struct fields refer to expecific error shapes
        if shape.exception() && service.name() != "Kinesis" {
            continue;
        }

        let type_name = mutate_type_name(service, name);

        let streaming = is_streaming_shape(service, name);
        let deserialized = deserialized_types.contains(&type_name);
        let serialized = serialized_types.contains(&type_name);

        if shape.shape_type == ShapeType::Structure {
            // If botocore includes documentation, clean it up a bit and use it
            if let Some(ref docs) = shape.documentation {
                writeln!(writer, "{}", crate::doco::Item(docs))?;
            }

            // generate a rust type for the shape
            if type_name != "String" {
                let generated = if shape.eventstream() {
                    generate_event_enum(service, &type_name, shape, protocol_generator)
                } else {
                    generate_struct(
                        service,
                        &type_name,
                        shape,
                        streaming,
                        serialized,
                        deserialized,
                        protocol_generator,
                    )
                };
                writeln!(writer, "{}", generated)?;
            }
        }

        if streaming {
            // Add a second type for streaming blobs, which are the only streaming type we can have
            writeln!(
                writer,
                "pub type {} = ::rusoto_core::ByteStream;",
                mutate_type_name_for_streaming(&type_name)
            )?;
        }

        if deserialized {
            if let Some(deserializer) =
                protocol_generator.generate_deserializer(&type_name, shape, service)
            {
                assert!(protocol_generator.deserialize_trait().is_none());
                writeln!(writer, "{}", deserializer)?;
            }
        }

        if serialized {
            if let Some(serializer) =
                protocol_generator.generate_serializer(&type_name, shape, service)
            {
                assert!(protocol_generator.serialize_trait().is_none());
                writeln!(writer, "{}", serializer)?;
            }
        }
    }
    Ok(())
}

fn generate_event_enum<P>(
    service: &Service<'_>,
    name: &str,
    shape: &Shape,
    protocol_generator: &P,
) -> String
where
    P: GenerateProtocol,
{
    let derived = vec!["Debug", "Clone", "PartialEq"];
    let attributes = format!("#[derive({})]", derived.join(","));

    assert!(!shape.members.is_none() && !shape.members.as_ref().unwrap().is_empty());
    format!(
        "{attributes}
        pub enum {name} {{
            {struct_fields}
        }}

        {deserialize_impl}
        ",
        attributes = attributes,
        name = name,
        struct_fields = generate_event_enum_fields(service, shape, protocol_generator),
        deserialize_impl =
            protocol_generator.generate_event_enum_deserialize_impl(service, name, shape),
    )
}

fn generate_event_enum_fields<P: GenerateProtocol>(
    service: &Service<'_>,
    shape: &Shape,
    protocol_generator: &P,
) -> String {
    shape
        .members
        .as_ref()
        .unwrap()
        .iter()
        .filter_map(|(member_name, member)| {
            if member.deprecated == Some(true) {
                return None;
            }

            let mut lines: Vec<String> = Vec::new();

            if let Some(ref docs) = member.documentation {
                lines.push(crate::doco::Item(docs).to_string());
            }

            let member_shape = service.shape_for_member(member).unwrap();
            let rs_type = get_rust_type(
                service,
                &member.shape,
                member_shape,
                member.streaming(),
                protocol_generator.timestamp_type(),
            );

            lines.push(format!("{}({}),", member_name, rs_type));

            Some(lines.join("\n"))
        })
        .collect::<Vec<String>>()
        .join("\n")
}

fn generate_struct<P>(
    service: &Service<'_>,
    name: &str,
    shape: &Shape,
    streaming: bool,
    serialized: bool,
    deserialized: bool,
    protocol_generator: &P,
) -> String
where
    P: GenerateProtocol,
{
    let mut derived = vec!["Debug"];
    let mut doc = "".to_owned();

    let not_streaming = !streaming && streaming_members(shape).next().is_none(); // bytestreams
    let contains_eventstreams = contains_eventstreams(service, shape); // structured event streams

    // Streaming is implemented with Box<Stream<...>>, so we can't derive Clone nor PartialEq.
    // This affects both the streaming struct itself, and structs which contain it.
    // Eventstreams are similarly implemented using non-plain data structures.
    if not_streaming && !contains_eventstreams {
        derived.push("Clone");
        derived.push("PartialEq");
    }

    if !contains_eventstreams {
        derived.push("Default");
    }

    if serialized {
        if let Some(serialize_trait) = protocol_generator.serialize_trait() {
            derived.push(serialize_trait);
        }
    }

    if deserialized {
        if let Some(deserialize_trait) = protocol_generator.deserialize_trait() {
            derived.push(deserialize_trait);
        }
    }

    derived.sort();

    let attributes = format!("#[derive({})]", derived.join(","));
    let mut test_attributes = String::new();
    if derived.iter().any(|&x| x == "Deserialize") && !derived.iter().any(|&x| x == "Serialize") {
        test_attributes.push_str(
            &"\n#[cfg_attr(any(test, feature = \"serialize_structs\"), derive(Serialize))]",
        );
    } else if deserialized && !derived.iter().any(|&x| x == "Serialize") {
        test_attributes
            .push_str(&"\n#[cfg_attr(feature = \"serialize_structs\", derive(Serialize))]");
    }
    if serialized && !derived.iter().any(|&x| x == "Deserialize") && not_streaming {
        test_attributes
            .push_str(&"\n#[cfg_attr(feature = \"deserialize_structs\", derive(Deserialize))]");
    }

    let definition = if shape.members.is_none() || shape.members.as_ref().unwrap().is_empty() {
        format!(
            "{attributes}{test_attributes}
            pub struct {name} {{}}
            ",
            attributes = attributes,
            test_attributes = test_attributes,
            name = name,
        )
    } else {
        // Serde attributes are only needed if deriving the Serialize or Deserialize trait
        let need_serde_attrs = derived
            .iter()
            .any(|&x| x == "Serialize" || x == "Deserialize");
        format!(
            "{attributes}{test_attributes}
            pub struct {name} {{
                {struct_fields}
            }}
            ",
            attributes = attributes,
            test_attributes = test_attributes,
            name = name,
            struct_fields =
                generate_struct_fields(service, shape, name, need_serde_attrs, protocol_generator),
        )
    };

    let mut implementation = "".to_owned();

    for operation in service.operations_for_shape(name) {
        doc.push_str(&format!(
            "/// see [{}::{}]\n",
            service.service_type_name(),
            operation.name().to_snake_case()
        ));
        if let Some(pagination) = service.pagination(&operation.name()) {
            let key_type = get_pagination_key_type(
                &pagination,
                service,
                operation,
                protocol_generator.timestamp_type(),
            )
            .expect("pagination should have a key type");
            let page_type = get_pagination_item_type(
                &pagination,
                service,
                operation,
                protocol_generator.timestamp_type(),
            )
            .expect(&format!(
                "pagination should have a item type {} {:?}",
                operation.name, pagination
            ));

            if operation.input_shape() == name {
                let key_code = if let Some(input_token) = pagination.input_token.only() {
                    format!("self.{} = key;", input_token.to_snake_case())
                } else {
                    pagination
                        .input_token
                        .as_slice()
                        .iter()
                        .enumerate()
                        .map(|(i, input_token)| {
                            format!("self.{} = key.{};", input_token.to_snake_case(), i)
                        })
                        .collect::<Vec<String>>()
                        .join("\n")
                };

                implementation = format!(
                    "
                    impl PagedRequest for {name} {{
                        type Token = {key_type};
                        fn with_pagination_token(mut self, key: {key_type}) -> Self {{
                            {key_code}
                            self
                        }}
                    }}
                    ",
                    name = name,
                    key_code = key_code,
                    key_type = key_type
                );
            } else {
                let mut impls = vec![];
                let mut trait_impls = vec![];
                if let Some(result_key) = pagination.result_key.only() {
                    let shape_name = get_pagination_item_shape(pagination, service, operation)
                        .expect("pagination result should exist");

                    let shape = service
                        .get_shape(&shape_name)
                        .expect("pagination result shape should exist");

                    let mapper = if shape.shape_type == ShapeType::List {
                        ""
                    } else {
                        ".map(|x| vec![x])"
                    };
                    impls.push(format!(
                        "
                    fn pagination_page_opt(self) -> Option<Vec<{page_type}>> {{
                        {page_code}{mapper}
                    }}",
                        page_code = extract_pagination_output(
                            &JMESPath::parse(&result_key),
                            service,
                            name,
                            true
                        ),
                        page_type = page_type,
                        mapper = mapper
                    ));

                    trait_impls.push(format!(
                        "
                      fn into_pagination_page(self) -> Vec<{page_type}> {{
                        self.pagination_page_opt().unwrap_or_default()
                      }}
                    ",
                        page_type = page_type
                    ));
                } else {
                    trait_impls.push(format!(
                        "
                    fn into_pagination_page(self) -> Vec<{page_type}> {{
                        vec![self]
                      }}
                    ",
                        page_type = page_type
                    ));
                };

                let key_code = if let Some(output_token) = pagination.output_token.only() {
                    extract_pagination_output(&JMESPath::parse(&output_token), service, name, true)
                } else {
                    format!(
                        "({})",
                        pagination
                            .output_token
                            .as_slice()
                            .iter()
                            .map(|path| format!("self.{}.clone()", path.to_snake_case()))
                            .collect::<Vec<String>>()
                            .join(", ")
                    )
                };

                if let Some(more_results) = &pagination.more_results {
                    impls.push(format!(
                        "
                        fn has_another_page_opt(&self) -> Option<bool> {{
                            {}
                        }}
                    ",
                        extract_pagination_output(
                            &JMESPath::parse(&more_results),
                            service,
                            name,
                            true
                        )
                    ));
                    trait_impls.push(
                        "
                        fn has_another_page(&self) -> bool {{
                            self.has_another_page_opt().unwrap_or(false)
                        }}
                    "
                        .to_owned(),
                    );
                } else {
                    trait_impls.push(
                        "
                    fn has_another_page(&self) -> bool {{
                        self.pagination_token().is_some()
                    }}"
                        .to_owned(),
                    );
                };

                implementation = format!(
                    "
                    impl {name} {{
                        {impls}
                    }}

                    impl PagedOutput for {name} {{
                        type Item = {page_type};
                        type Token = {key_type};
                        fn pagination_token(&self) -> {key_type} {{
                            {key_code}
                        }}
                        {trait_impls}
                    }}
                    ",
                    name = name,
                    key_type = key_type,
                    key_code = key_code,
                    page_type = page_type,
                    impls = impls.join("\n"),
                    trait_impls = trait_impls.join("\n")
                );
            }
        }
    }
    doc + &definition + "\n" + &implementation
}

fn generate_struct_fields<P: GenerateProtocol>(
    service: &Service<'_>,
    shape: &Shape,
    shape_name: &str,
    serde_attrs: bool,
    protocol_generator: &P,
) -> String {
    shape.members.as_ref().unwrap().iter().filter_map(|(member_name, member)| {
        if member.deprecated == Some(true) {
            return None;
        }

        let mut lines: Vec<String> = Vec::new();

        if let Some(ref docs) = member.documentation {
            lines.push(crate::doco::Item(docs).to_string());
        }

        if serde_attrs {
            lines.push(format!("#[serde(rename=\"{}\")]", member_name));

            if let Some(member_shape) = service.shape_for_member(member) {
                if member_shape.shape_type == ShapeType::Blob {
                    lines.push(
                        "#[serde(
                            deserialize_with=\"::rusoto_core::serialization::SerdeBlob::deserialize_blob\",
                            serialize_with=\"::rusoto_core::serialization::SerdeBlob::serialize_blob\",
                            default,
                        )]".to_owned()
                    );
                } else if member_shape.shape_type == ShapeType::List {
                    if let Some(ref list_element_member) = member_shape.member {
                        if let Some(list_element_shape_type) = service.shape_type_for_member(list_element_member) {
                            if list_element_shape_type == ShapeType::Blob {
                                lines.push(
                                    "#[serde(
                                        deserialize_with=\"::rusoto_core::serialization::SerdeBlobList::deserialize_blob_list\",
                                        serialize_with=\"::rusoto_core::serialization::SerdeBlobList::serialize_blob_list\",
                                        default,
                                    )]".to_owned()
                                );
                            }
                        }
                    }
                }
            }

            if !shape.required(member_name) {
                lines.push("#[serde(skip_serializing_if=\"Option::is_none\")]".to_owned());
            }
        }

        let member_shape = service.shape_for_member(member).unwrap();
        let rs_type = get_rust_type(service,
                                    &member.shape,
                                    member_shape,
                                    member.streaming(),
                                    protocol_generator.timestamp_type());
        let name = generate_field_name(member_name);

        // For structs that can contain another of themselves, we need to box them.
        if shape_name == rs_type {
            if shape.required(member_name) {
                lines.push(format!("pub {}: Box<{}>,", name, rs_type))
            } else if name == "type" {
                lines.push(format!("pub aws_{}: Box<Option<{}>>,", name,rs_type))
            } else {
                lines.push(format!("pub {}: Box<Option<{}>>,", name, rs_type))
            }
        } else {
            // In the official documentation the fields revision_change_id and created are required
            // but when looking at the responses from aws those are not always set.
            // See https://github.com/rusoto/rusoto/issues/1419 for more information
            if service.name() == "CodePipeline" && shape_name == "ActionRevision" && name == "revision_change_id" || name == "created" {
                lines.push(format!("pub {}: Option<{}>,", name, rs_type))
            // In the official documentation the field startedAt is required but responses lack for the field on certain situations.
            // See https://github.com/rusoto/rusoto/issues/1736 and https://github.com/boto/botocore/issues/2030 for more information.
            } else if service.name() == "AWS Batch" && shape_name == "JobDetail" && name == "started_at" {
                lines.push(format!("pub {}: Option<{}>,", name, rs_type))
            // In pratice, Lex can return null values for slots that are not filled. The documentation
            // does not mention that the slot values themselves can be null.
            } else if service.name() == "Amazon Lex Runtime Service"  && shape_name == "PostTextResponse" && name == "slots"{
                lines.push(format!("pub {}: Option<::std::collections::HashMap<String, Option<String>>>,", name))
            } else if name == "match" {
                lines.push(format!("pub route_{}: Option<{}>,", name, rs_type))
            } else if shape.required(member_name) {
                lines.push(format!("pub {}: {},", name, rs_type))
            } else if name == "type" {
                lines.push(format!("pub aws_{}: Option<{}>,", name,rs_type))
            } else {
                lines.push(format!("pub {}: Option<{}>,", name, rs_type))
            }
        }

        Some(lines.join("\n"))
    }).collect::<Vec<String>>().join("\n")
}

fn error_type_name(service: &Service<'_>, name: &str) -> String {
    let type_name = mutate_type_name(service, name);
    format!("{}Error", type_name)
}
